/* eslint-disable react/no-unknown-property */
/* eslint-disable array-callback-return */
/* Auto-generated by: https://github.com/pmndrs/gltfjsx */
import React, {
  useRef, useMemo, useState, Component,
} from 'react';
import * as SkeletonUtils from 'three/examples/jsm/utils/SkeletonUtils';
import {
  useGLTF, Merged, useAnimations,
} from '@react-three/drei';

import { useGraph } from '@react-three/fiber';
import { useStore } from '../../store/store';

// useGLTF.preload('./assets/gameModels/webexperience.gltf');
useGLTF.preload('./assets/gameModels/webexperience-new.gltf');

export function useSkinnedMeshClone(path) {
  const { scene, materials, animations } = useGLTF(path);
  const clonedScene = useMemo(() => SkeletonUtils.clone(scene), [scene]);
  const { nodes } = useGraph(clonedScene);

  return {
    clonedScene, materials, animations, nodes,
  };
}

/**
 * The Model function is a React component that renders the hand model.
 * It uses the useGLTF hook to pull in gltf data from an external file, and then passes it into a group object.
 * The group object is used to hold all of the objects that make up the hand model, including materials and skeletons.
 *
 * @param {instances Pass in the number of instances to render
 * @param ...props} Pass in the properties of the component
# the `props` parameter is used to pass in the properties of a component
 *
 * @return A group of objects
 *
 */
export default function Model({ /* instances */ ...props }) {
  const group = useRef();
  // const { nodes, materials, animations } = useSkinnedMeshClone('./assets/gameModels/webexperience.gltf');
  const { nodes, materials, animations } = useSkinnedMeshClone('./assets/gameModels/webexperience-new.gltf');
  const { actions } = useAnimations(animations, group);

  // pull in selection input from store
  // const { selected } = useStore((state) => state.appContext);

  //   hand controls
  const { methods: { changeHand }, context: { hand: { animationsPlaying, propsUsing, numHands } } } = useStore((state) => state.threejsContext);
  const _handProps = ['Iphone', 'Emoji', 'Hammer', 'Pencil', 'VR', 'Paper'];
  const _actions = ['wave', 'hold', 'snap', 'write', 'build'];

  const determineProp = React.useCallback(() => {
    const props = {
      Iphone: () => (
        <skinnedMesh
          name="iphone_13"
          geometry={nodes.iphone_13.geometry}
          material={nodes.iphone_13.material}
          skeleton={nodes.iphone_13.skeleton}
        />
      ),
      // Emoji: () => (
      //   <skinnedMesh
      //     name="Emoji"
      //     geometry={nodes.Emoji.geometry}
      //     material={nodes.Emoji.material}
      //     skeleton={nodes.Emoji.skeleton}
      //   />
      // ),
      Hammer: () => (
        <group name="Hammer">
          <skinnedMesh
            name="Cylinder002"
            geometry={nodes.Cylinder002.geometry}
            material={nodes.Cylinder002.material}
            skeleton={nodes.Cylinder002.skeleton}
          />
          <skinnedMesh
            name="Cylinder002_1"
            geometry={nodes.Cylinder002_1.geometry}
            material={nodes.Cylinder002_1.material}
            skeleton={nodes.Cylinder002_1.skeleton}
          />
        </group>
      ),
      Pencil: () => (
        <group name="pencil">
          <skinnedMesh
            name="Cylinder003"
            geometry={nodes.Cylinder003.geometry}
            material={nodes.Cylinder003.material}
            skeleton={nodes.Cylinder003.skeleton}
          />
          <skinnedMesh
            name="Cylinder003_1"
            geometry={nodes.Cylinder003_1.geometry}
            material={nodes.Cylinder003_1.material}
            skeleton={nodes.Cylinder003_1.skeleton}
          />
          <skinnedMesh
            name="Cylinder003_2"
            geometry={nodes.Cylinder003_2.geometry}
            material={nodes.Cylinder003_2.material}
            skeleton={nodes.Cylinder003_2.skeleton}
          />
          <skinnedMesh
            name="Cylinder003_3"
            geometry={nodes.Cylinder003_3.geometry}
            material={nodes.Cylinder003_3.material}
            skeleton={nodes.Cylinder003_3.skeleton}
          />
          <skinnedMesh
            name="Cylinder003_4"
            geometry={nodes.Cylinder003_4.geometry}
            material={nodes.Cylinder003_4.material}
            skeleton={nodes.Cylinder003_4.skeleton}
          />
          <skinnedMesh
            name="Cylinder003_5"
            geometry={nodes.Cylinder003_5.geometry}
            material={nodes.Cylinder003_5.material}
            skeleton={nodes.Cylinder003_5.skeleton}
          />
          <skinnedMesh
            name="Cylinder003_6"
            geometry={nodes.Cylinder003_6.geometry}
            material={materials.eraser}
            skeleton={nodes.Cylinder003_6.skeleton}
          />
        </group>
      ),
      VR: () => (
        <group name="vr_headsest">
          <skinnedMesh
            name="Cube003"
            geometry={nodes.Cube003.geometry}
            material={nodes.Cube003.material}
            skeleton={nodes.Cube003.skeleton}
          />
          <skinnedMesh
            name="Cube003_1"
            geometry={nodes.Cube003_1.geometry}
            material={nodes.Cube003_1.material}
            skeleton={nodes.Cube003_1.skeleton}
          />
        </group>
      ),
      Paper: () => (
        <group
          name="paper"
          position={[-2.161, -0.937, 0.85]}
          rotation={[-2.989, 1.173, 3.006]}
          scale={[0.752, 0.752, 0.752]}
        >
          <mesh
            name="Plane"
            castShadow
            receiveShadow
            geometry={nodes.Plane.geometry}
            material={materials.Material}
          />
          <mesh
            name="Plane_1"
            castShadow
            receiveShadow
            geometry={nodes.Plane_1.geometry}
            material={nodes.Plane_1.material}
          />
          <mesh
            name="Checkmark"
            castShadow
            receiveShadow
            geometry={nodes.Checkmark.geometry}
            material={nodes.Checkmark.material}
            position={[-0.8, 0.125, 1.048]}
            scale={[249.691, 249.691, 249.691]}
          />
        </group>
      ),
      None: () => (
        <group
          name="paper"
          position={[-2.161, -0.937, 0.85]}
          rotation={[-2.989, 1.173, 3.006]}
          scale={[0.752, 0.752, 0.752]}
        />
      ),
    };

    return propsUsing.map((propName) => (React.createElement(props[propName])));
  }, [propsUsing]);

  const wave = () => {
    const start = () => {
      changeHand({
        animationsPlaying: ['wave'],
        propsUsing: ['None'],
      });
    };
    const end = () => {
      changeHand({
        animationsPlaying: ['hold'],
        propsUsing: [],
      });
    };
    return { start, end };
  };

  React.useEffect(() => {
    // const { start, end } = wave();
    // start();
    // setTimeout(() => end(), 2500);
  }, []);

  React.useEffect(() => {
    if (process.env.development) {
      console.log('===== Nodes =====');
      console.log(nodes);
      console.log('===== Group =====');
      console.log(group.current);
      console.log('===== Materials =====');
      console.log(materials);
      console.log('===== Actions =====');
      console.log(actions);
    }

    // get availible animations
    const {
      wave, hold, snap, write, build,
    } = actions;

    // toggle animations based on user input/scroll input
    // map through array with names, if name is not found, toggle off from actions
    // fadeIn(duration)
    // fadeOut(duration)
    // play()
    // reset()
    // stop()
    // stopFading()
    // halt()
    _actions.map((availibleAction) => {
      if (animationsPlaying.includes(availibleAction)) {
        actions[availibleAction]?.reset();
        actions[availibleAction]?.fadeIn(0.15);
        actions[availibleAction]?.play();
      } else {
        actions[availibleAction]?.reset();
        actions[availibleAction]?.fadeOut(0.55);
        actions[availibleAction]?.play();
      }
    });

    // toggle animated hands props, connected to objectBone.L
    // depending on user input/scroll input
    // items start at scale 0, then scale up to 1 when popping in and out
  }, [group, animationsPlaying]);

  return (
    <group
      ref={group}
      {...props}
      dispose={null}
    >
      <group name="Scene">
        <group
          name="handRig"
          onClick={() => {
            const pU = propsUsing;
            const nH = numHands;
            changeHand({
              animationsPlaying: ['wave'],
              propsUsing: ['Iphone'],
              numHands: 1,
            });
            setTimeout(() => {
              changeHand({
                animationsPlaying: ['hold'],
                numHands: nH,
                propsUsing: pU,
              });
            }, 2400);
          }}
        >
          {/* <axesHelper args={[1, 1, 1]} scale={4} position={[0, 0, 0]} /> */}
          <primitive object={nodes.forearmL} />
          <skinnedMesh
            name="cuffs"
            geometry={nodes.cuffs.geometry}
            material={materials['Procedural Simple Cloth']}
            skeleton={nodes.cuffs.skeleton}
          />
          <skinnedMesh
            name="hand"
            geometry={nodes.hand.geometry}
            material={nodes.hand.material}
            skeleton={nodes.hand.skeleton}
          />

          {/* <skinnedMesh
            name="watch"
            geometry={nodes.watch.geometry}
            material={nodes.watch.material}
            skeleton={nodes.watch.skeleton}
          /> */}
        </group>
        {/** Props */}
        {propsUsing.length > 0 && (
          <>
            {determineProp()}
          </>
        )}
        vb
      </group>
    </group>
  );
}
